Structure:
 Page
  nodes: Node[]
 Node
  indent: number
  content: Block | Line
  children: Node[]
 interface Block
  startline: string
  endline: string
  content: string[]
 CodeBlock
 TableBlock
 BlankBlock
 Line
  raw: string
  inline_elements: InlineElement[]
 QuoteLine
 BlankLine
 interface InlineElement
 Plain
  text: string
 Link
  url: string
  text: string
 Image
  url: string
  text: string
 Literal
  text: string
 ---
 つまり、
  Pageはn-Nodeを持つ
  Nodeの本体はBlockまたはLine
  Lineはn-InlineElementを持つ

Command:
 python dobu.py OPTIONS

options:
 以下は入力ファイル。単一かディレクトリ丸ごと
 -i (Input-path)
  入力ファイルを指定
 --from-cd
  カレントディレクトリをインプットにする。`./*.scb`と同義
 
 以下はフォーマット指定。なければ --to-dobu がデフォ
 --to-dobu
 --to-html
 
 以下は出力形式指定。なければstdout
 --file
  ファイルに出す
  出力ファイル名は固定

 以下はフォーマットごとのオプション。`--FORMAT-OPTIONNAME`という形にする
 --html-template (template-htmlfile-path)
  `{contents}`と書かれた部分に、変換されたHTMLが挿入される

 🐰
  出力ファイル名の指定はない。常に`{basename}.{output-format-extension}`で固定する。
   1 そんなところで迷いたくないので
   2 リンク文字列の変換を行う以上、名前のフォーマットを固定しないといけないので
 
 ❌以下はボツ
  -g input Glob pattern
   自由に指定させるためにglobに投げる🐰
   デフォは `/**/*.scb`
   まずはminimumにつくりたいので後回しでよい

formats:
 Human Readable(to string)、拡張子は .dobu
 HTML

dobuフォーマット
 mebj用のreadable format
 人間も読めるし、テストコードなどで照合もしやすい

登場人物
 1 scb
  入力ファイルフォーマット。hidemaru scbフォーマット
 2 mebject
  scbから変換する中間オブジェクト

✅HTMLのカスタマイズ
 headerとfooter、あるいはテンプレートつくって`{contents}`と書いたところに埋め込む、みたいなやつ
 cssでいじれるようにするためクラス名はちゃんとつけるべき
  ここは試行錯誤しながら、過不足なく揃えていくしかないなー🐰
 どういうcssクラスをつけるかは外から与えられるようにしたい
  scrapbox-readerのやつを使いたい、とかしたいし
  どうやればいいんだ……？
   いったん後回し……
   とりあえず自分用なのでハードコードすればいいさ……🐰

✅中間オブジェクト
 scb to XXX
 XXX to HTML
 XXX to Markdown
 このXXXにあたるデータ構造のこと
 最初は「中間言語」と呼んでいたが、文法仕様があるわけではなく単にオブジェクトとして保持して扱うだけなので、たぶん「オブジェクト」が正しい🐰
 長いので mediator object = mebject とでも呼ぶことにする🐰
  通称mebj

✅コマンド名
 良いの思いつかない……
 打ちやすいのがいい
 今は雑にdocとかにしておく🐰
  いや、わからんのでなし
 document builder で dobu
  ドブｗ

---
2 structure決めるまで

✅クラインを扱うためにはどうする？
 page側でclineの操作をサポートしたい？
 空行ブロックをつくれば事実上サポートできることになる？
  個人的にこれは欲しい🐰
  空行は解釈に曖昧性が出やすいので、このパーサ側で全部要素化してしまいたい
 が、利用者側でクライン使うってのは、直近はなさそう
  クライン数でランキングつくるくらいか？インデックスページとして
 後からも足せるし、クラインは要らないな🐰
✅あとは、空行の取り扱い
 空行ブロック案
  こっちは強引って気がする
  ブロックはインデント下げてその中を隠蔽するってイメージなので……
 空ライン案
  いったんこっちでいいか🐰

✅ただのリストもブロックにするべきか？
 Blockのメンバ設計とも絡む
 まったくピンと来ねえんだけど……🐰
 が、ブロックを下記案1 隠蔽式にしたので、ただのリストは無しでいいのでは？
  それにリストブロックサポートすると、compositパターンみたいなことになる
  ちょっと煩雑かなぁ
 でもリストブロックにして構造化しておけば、利用者側で扱うのが楽だ
  行入れ替えとか
  いや、だから、行入れ替えは今回しねえだろ🐰
  エディタつくるわけじゃないし
 ならリストブロックはなしでいい🐰

✅ブロック内の要素はどう表現する？クラス？
 ブロックごとに系統が違うから実装が独自になるよねぇ……
  例:codeだとただの行だろうし、tableだと頑張ってパースしてテーブル形式にしたい
 案1 XXXBlockでは内部的にパース処理を書いて、I/Fとしては便利メソッドやプロパティを見せるだけ
 案2 案1+ブロックの下層にあたる構造もちゃんと定義する
  無理じゃね？
 ……案1でいいか。他に浮かばん。案2は綺麗さ求めすぎな気もするしね →[手段の目的化]
✅引用はどう持たせるべきか。frontline的なやつとか、Line.is_quoteとか
 is_quoteの場合、判定処理や本文抜き出しをLineが担うことになる。他にもfront系が来たらLineの責務が増える。
 frontlineelementは違う。element単体で完結するべき（本文も含んでいるべき）だが、quoteは`>`しか含んでない。違う。
 QuoteLine……くらいしかねえよなぁ
✅ネストはどこで持たせる？
 後述のとおり、Nodeで持たせる
 利用者は、Nodeが持つインデント情報を「必要なら」使う
  Scrapboxレベルのネスト表現力（ネスト中にコードブロックとか）を持ってるとは限らないので、強制はしない🐰

ブロックとは
 コンテンツも機能も一手に引き受けた単位
 Pageからは「ほげほげブロック」ということしか見えない
  lineがどうなってるとかは見えない🐰🐰
 逆を言えば、ほげほげブロックは、自分が持つlinesをどう扱いどう見せるかを自身が責任負う

---

1 下調べと検討初手

code:bnf2
 <page> ::= <nodes>
 <nodes> ::= <node> <nodes> | ""

 <node> ::= <block> | <line>
 <block> ::= <codeblock> | <tableblock> | <quoteblock>

 <line> ::= <indent> <inline-elements>
 <inline-elements> ::= <inline-element> <inline-elements> | ""
 <inline-element> ::= <plain> | <link> | <image> | <literal>

 <indent> ::= " " <indent> | ""
:c

code:bnf1
 <page> ::= <nodes>
 <nodes> ::= <node> <nodes> | ""

 <node> ::= <block> | <line>
 <block> ::= <codeblock> | <tableblock> | <quoteblock>

 <line> ::= <indent> <inline-elements>
 <inline-elements> ::= <inline-element> <inline-elements> | ""
 <inline-element> ::= <plain> | <link> | <image> | <literal>

 <indent> ::= " " <indent> | ""
:c

 1行内にはnのインライン要素があるという感じ
  class Line
   content: InlineElement[]
 インライン要素は色々あるので、基底を定義してこれを実装させる
  interface InlineElement
  class Plain
  class Link
  class Literal
  class Image
  class CodeStart
  class InCode
  class CodeEnd

データ構造
 ルート
  class Page
   nodes: Node[]
 行はノードとして扱う感じ
  class Node
   indent: number
   content: Line
   children: Node[]
 1行内にはnのインライン要素があるという感じ
  class Line
   content: InlineElement[]
 インライン要素は色々あるので、基底を定義してこれを実装させる
  interface InlineElement
  class Plain
  class Link
  class Literal
  class Image
  class CodeStart
  class InCode
  class CodeEnd

❌引用はどう表現する？
 ブロックでいい🐰
  最低でも行まるごとになる。これは1行からなるブロックとみなせる
  そもそも引用記法は本来はブロック的だよね
   ただ先頭に`>`付ける書き方が楽だからそうなってる（インラインっぽく感じる）だけで
 いや、いいの、か……？
  でもinlineにする場合、indentみたいに「先頭につける」性質があるから、また特殊なんだよなぁ
  愚直にやるならinline, frontline, backlineと3パターンサポートする羽目になる🐰
   そして構文的にはこれが正しい
   実際、scrapboxでも引用表記の中にリンクとか書ける。これはinlineとfrontlineが同列だからだ🐰🐰

クラインは？
 scbを扱う上で俺がかなり意識している概念
 サポートしたい
 Blankみたいな概念がある？
  Nodeと同列の概念で、n行の空行を表現する
  Pageとは、NodeとBlankからなるリストと呼ぶことができる
  ……いや、Nodeの中にBlankを入れればいいのか🐰
 そしてBlankも二つあるけど
  indent=0のblank
  indent>0のblank
  つまりどこで（どの階層で）区切っているかが違う🐰

ネストはどう表現する？
 Nodeにindent: numberを持たせる、ではダメなんだっけ？
 問題ないだろ🐰
  懸念してた「並び替え操作しやすくする」は、リストの操作の話なのでここじゃねえし
  ネストの付け方に制約はないので、ポリシー的なものを搭載する必要もない
   別に
          こんな風に
     1段ずつネストせず一気に
      飛ばしたっていいんだし
 本当に？🐰
  HTML側はそれじゃ表現できなくね？
  1段ずつの構造であるべきじゃね？
  じゃあ1段ずつが守られてないscbがあったとして、どうするの？
   エラーにする？うそぅ？
   どう見せるかは中間言語使う側が考えることだろ🐰
    HTMLを使う場合、HTMLでは使えないので「preで見せるか」とかやればいい
    あるいはscrapbox-reader的に行指向にしてもいいし
 ---
 Nodeとして「List」をサポートする案は？
  より木構造的になる
  いや、indentわからん（いちいち木を走査して深さを計算する必要がある）くてだるいよね
  メリットは、
   並び替えするときにList Nodeまるごと移せばいいだけになるので楽
  が、やっぱりNodeではない気がするなぁ
   BlockもListの性質を持つときがある。並列ではない
  いや、やっぱり扱いたいですよねぇ
   一貫したデータ構造にしたい🐰
  before
   `<node> ::= <block> | <line>`
  after
   ？
  block, list, line
  listはlistblock？
 要らんだろ。並び替えはしないよね🐰🐰
  今ここで検討してるのはただの変換だ。
 ---
 いや、行指向で行こう
  HTMLなど変換先側の言語がネストに対応しているとは限らない
   いや、それをいうならそもそもリストの中にブロック持たせる、自体がHTMLは対応していないが……ｗ
  ので、見かけ上はフラットな構造で持たせておいて、インデントはプロパティとして持っておいて各自解釈してよしなにしてもらう
   つまりインデントという「構造を示した値」があるので、それで表示を微調整してくれ、と（scrapbox-readerのやり方）
  page
   node(indent=0)
   node(indent=0)
   node(indent=1)
   ...
 

パース
 一行目から静的に行単位でパースする、でいいんだっけ？🐰
 良いでしょ
  ただ、ブロックの解釈時は、始点見つけたら終点まで一気に解釈して、続きはその後ろから、って感じになるはず🐰
 1 まずはnodeレベルでリストつくる
 2 その後、node各々をinlineレベルでリスト化する

✅目的は？ ほか
 1 この読み物をHTMLで公開するために、変換をつくること
 2 scb記法一般について、1ができるようにしたい
 3 クラインなどよく使う概念も取り込んで、プログラムで扱いやすくしたい（漠然！）
 ---
 結論: 1でも結局中間言語作るレベルじゃないとたぶん通用しないので、素直に2のつもりでやればよろし🐰
 ---
 fimp🐰
  3は[手段の目的化]感
  できれば2が欲しい。この読み物以外にもscbは結構使っているし、手元で書いたのを公開したいときとかにこれがあると仕事でも便利だろうから
  が、直近は1でもいい。だらだらしても仕方ないし、2はscb記法ちゃんと考えて変換もちゃんとつくるってことだから一朝一夕ではない。1でいいのでは？
 仮に1に特化して実装するとしたら？🐰
  scb to htmlを直に書くことになる
  厳密に設計せずとも、適当にパースすればよい
   が、行指向的に前から一行ずつ処理する、だと地獄を見たので、nodeをつくる（scrapbox-parser）系のアルゴリズムにはしたい
    [stakiran/scbjson2ghpages: Scrapbox Exported JSON to Markdown for GitHub Pages. https://github.com/stakiran/scbjson2ghpages]
   他に良いアルゴリズムはあるか？思いつかん……
  あとでデバッグが大変なので、テストコードは先にガッツリやってしまいたい
  いや、結局scb to 中間言語要るなぁ🐰🐰
   ただのそのクオリティをどこまで突き詰めるかの問題
 うん、scb to 中間言語と中間言語 to HTMLにしよう🐰

✅ブロックはどう表現する？
 中間言語としては、いちいちstart/in/endなんて意識したくない
 nodeレベルにすることにした

✅react使うかで悩んでいる構図
 inbox
  React側 まずは二行の箇条書きを表示する程度でつくればいいのでは
  スクボきほうのデータを直にフロントにもたせてしまうか、中間言語まではパイソンにするか。後者かな。他にもパイソンは使いそうだし。中間言語to、のひとつをリアクトでつくる。インポートするファイル(中間言語データが書かれている)を直につくりたさ……が、なんか微妙。前者でつくりきる方がいいか？もうひとつのコンポーネントにしちゃうとか
 もうフロントにデータ載せて動的に描画するのもアリか？
  いわゆるCSR、client side rendering になるのか？
  Reactって使える？
   使える
   まさにrender()の中でhtml文字列つくってるじゃんね🐰
 ---
 まとめると、
  scb to 中間言語はn言語でつくれる余地がある
   js
   py etc
  中間言語 to HTMLは以下のアプローチが考えられる
   1 何らかの言語でコマンドをつくる
   2 何らかの言語が読める形式に変換し、それを使ってその言語でツールをつくる
   で、react使う案は2になる
    scb to 中間言語して、
    中間言語データを、jsで読める形式にしてreactのpjに入れる
    あとはreactでよしなに、みたいな🐰
 どうしたい？🐰
  reactは何もわからないし、学びながらはきついので、いったんなし
  どちらかと言えば今後のためにもscb to HTMLが欲しい
   コマンドがあるといい
   慣れたpythonで良い

✅scb to 中間言語変換をつくる
 まずはこれをつくる
 で、その後、中間言語 to HTML とか、to Markdownとかすればいい
 中間言語の表現力は、まあHTML相当で良かろう🐰

✅ghpaages or vercel
 docs/ 配下の github pages でいい
  github actions
  面倒くさそうならvercelに逃げる🐰

✅阿部寛レベルの軽いサイトにしたいかも
 [阿部寛ウェブサイトのHTMLソースを見る]
 cssでbulletを消す、マージンとかも調整する
 scrapbox-readerどうしてるっけ？
  [scrapbox-readerを読む]
  ` <div style="margin-left: XXXXem;" class="line">XXXX</div>`でしたわ
  良いアイデア🐰
   これなら箇条書き内にコード記法、も表現できる（コード記法みたいな装飾で見せればいいだけ）
   そもそも箇条書き(ul and li)使わなくなるわけだし
